#!/usr/bin/env ruby
#
# NAME
#
#   yurt - YAML-Ruby template renderer
#
# SYNOPSIS
#
#   yurt [options] <template-file>
#   yurt --regen <output-file>
#
# OPTIONS
#
#   --data <data.yml|YAML-string>
#
#     Data in YAML format as a file or a string.
#
#   --require <path>
#
#     Require one or more Ruby files.
#
#   --output <output-file>
#
#     Output file.
#
#   --regen <output-file>
#
#     Regenerate an output file.
#
# DESCRIPTION
#
#   A proof of concept for a CLI template renderer using the ERB templating
#   engine.
#
#   The template file is written in ERB.  The template can use data supplied
#   by a YAML file or from one or more Ruby files.
#
#   A special 'generate_comment' variable is provided for the regeneration
#   feature.
#
# EXAMPLES
#
#   A basic example.
#
#     data.yml:
#
#       ---
#
#       name:
#         first: Rob
#         last: Donnelly
#
#     template.txt:
#
#       Hello <%= name.first %> <%= name.last %>
#
#     Command:
#
#       $ yurt --data data.yml template.txt
#
#     Output:
#
#       Hello Rob Donnelly
#
#   A example of regeneration.
#
#     template.rb
#
#       # <%= generate_comment %>
#       puts "Hello <%= name.first %>"
#
#     Initial command:
#
#       $ yurt --data data.yml template.rb --output output.rb
#
#     Output:
#
#       # Generated by: yurt --data 'fixtures/data2.yml' 'fixtures/template.rb'
#       puts "Hello Rob"
#
#     Regenerate command:
#
#       $ yurt --regen output.rb

require 'erb'
require 'yaml'
require 'optparse'

# This hack effectively implements a recursive OpenStruct using JSON.
#
# From: https://coderwall.com/p/74rajw/convert-a-complex-nested-hash-to-an-object
class ObjectifyHash
  require 'json'
  require 'ostruct'

  def self.call(hash)
    JSON.parse(hash.to_json, object_class: OpenStruct)
  end
end

class PathRelativeFrom
  require 'pathname'

  # FIXME: Only transform paths that are in $SBOX
  def self.relative_from(to_path, from_path)
    to_pathname = Pathname.new(File.expand_path(to_path))
    from_pathname = Pathname.new(File.expand_path(from_path))

    to_pathname.relative_path_from(from_pathname).to_s
  end
end

class ParseOptions
  def self.call
    options = Struct.new(:data, :command, :regen, :output, :requires).new
    options.requires = []

    OptionParser.new do |op|
      op.on('-d', '--data <file.yml|YAML-string>', 'Data in YAML format as a file or string') do |argument|
        options.data = argument
      end
      op.on('--regen <file>', 'Regenerate file') do |argument|
        options.regen = argument
      end
      op.on('--require <path>', 'Require one or more Ruby files') do |argument|
        options.requires << argument

        # Try to require absolute path or path relative to pwd. If that fails,
        # try requiring from loadpath.
        begin
          require File.expand_path(argument)
        rescue LoadError
          require argument
        end
      end
      op.on('--output <file>', 'Output file') do |argument|
        options.output = argument
      end
    end.parse!

    options
  end
end

class TransformOptions
  def self.call(options)

    options.command = RegenCommand.call(options)

    options
  end
end

class RegenCommand
  def self.call(options)
    if options.regen
      # Extract from first line of file
      # FIXME: Make more robust.  Handle errors.
      regen_command = File.open(options.regen, &:readline).match("Generated by: (.*)").captures.first
      regen_command.gsub!(File.basename($0), $0)
      regen_command += " --output #{options.regen}"
      puts "Running: #{regen_command}"
      exec(regen_command)
    else
      output_dir = Dir.pwd

      command = []
      command << File.basename($0)

      if options.data
        data = PathRelativeFrom.relative_from(options.data, output_dir)
        command << "--data '#{data}'"
      end

      options.requires.each do |path|
        command << "--require '#{path}'"
      end

      # FIXME: Include the --output option?

      command << ARGV
        .map { |x| PathRelativeFrom.relative_from(x, output_dir) }
        .map { |x| "'#{x}'" }

      command.join(' ')
    end
  end
end

options = TransformOptions.call(ParseOptions.call)

input_text = ARGF.read
input_filename = ARGF.filename

data_text = File.exist?(options.data) ? File.read(options.data) : options.data
data_hash = YAML.load(data_text) # FIXME: Catch YAML parsing errors

object = ObjectifyHash.call(data_hash)
object.generate_comment = "Generated by: #{options.command}"

template = ERB.new(input_text, nil, '-')
template.filename = input_filename

output = options.output ? File.open(options.output, 'w') : $stdout
output.puts template.result(object.instance_eval { binding })
